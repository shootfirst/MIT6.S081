# MIT6.S081
麻省理工2020年秋操作系统实验

首先需要说明的是各个实验代码位于不同的分支，大部分是20年的实验。其中alloc和net是19年的，因为本人觉得伙伴分配系统需要熟悉一下，19年的alloc是伙伴分配系统，还有就是net也是19
年的，20年虽然有net，但是不如19详细，19除了底层网络驱动，还有上层的socket实现。下面是我的代码实现思路。

## util

这是入门的第一个实验，是写五个利用内核系统调用的用户态程序。

### sleep

实验很简单，会调用内核提供的系统调用sleep即可。注意非法参数的传递，如果只传递了一个参数，没有指定要sleep的时间，则使用exit(-1)异常退出。

### pingpong

实验难度我觉得要远大于sleep，可是不知为啥官方把两个都标记为easy。要写对这个实验，首先需要对内核进程的创建有了解。需要注意的是，调用fork创建子进程时，不仅仅是内存空间内容一
模一样，文件描述符也是一样的。这就是利用管道进行进程间通信的关键所在。首先这个父子进程间通信，我使用了两个管道，其实一个管道即可做到。父进程先在写端写字节，然后子进程读。子
进程读完后，又可以在相同写端写字节，然后父进程读之。因为之前做过本校的os实验，本校os实验需要两个管道，所以受此影响。
ps: pingpong的打印检查很严格（其实凡是涉及到打印检查的都很严格，空格，标点符号都要和题目给的保持一致，我就是因为received写成recieved，不给我通过，我硬生生卡了两小时）

### primes

实验是要求实现质数筛子，这是这个算法的示意图：
![](sieve.png)


我的思路是先保存2-36至数组pipeline当中，然后通过primesieve函数筛选。该函数创建子进程，父进程负责将pipeline通过管道传递给子进程，而子进程每次从管道读取一个数，按照此算法：

p = get a number from father
print p
loop:
    n = get a number from father
    if (p does not divide n)
        send n to pipeline

第一次将读取的数p打印并且保存，后面从父进程读取的数据若不能整除p则传递到pipeline数组中。结束后将pipeline数组传递给下一个primessieve函数，相当于是传递给下一组管道。递归调用
结束的条件是没有一个数可以被送进pipeline数组。
        
### find

这个实验挺有意思。不过对linux相关文件系统部分没有了解可能会耗费一些时间去阅读官方推荐的ls.c文件以及相关函数与数据结构。核心思路如下：
首先对文件类型进行判断，若是文件则直接打印其路径内容，若是目录则通过dirent获取该目录下的所有目录项，依次进行递归find查找，注意.和..需要跳过，它们分别表示父目录和当前目录，
若不跳过则会导致无限递归栈溢出。递归调用时注意将当前目录项的文件名也接到当前路径之后，这样才能打印出正确的路径名。最后别忘了关闭文件哦。

### xargs

这实验一开始看上去我是有点小疑惑的。一开始我是不清楚xargs前面的字符串是否也包含在argv中。后面通过打印发现是不是的。该实验是要把输入命令A改成执行命令B

A: x xargs y
B：y x

其中"xargs y"是argv的内容，"xargs"是argv[0]，而"x"则还位于标准输入。我们将其读取然后拼接到新argv中。

我们需要构建新的argv数组B，然后执行之。具体而言是首先将老argv中的2-n(n是其长度)个参数先copy过去，copy过程先注意要为字符串分配空间。第一个是xrags，第二个是xargs要执行的命
令。所以我们从第二个开始copy。copy完之后，xargs前面的x我们也将其加入(看成整体除非遇到换行符)。最后我们在新argv数组最后加上0表示结束。

一共花费时间：7小时

## syscall

该实验很简单。设计的很好，第一部分能让我们大概了解xv6系统调用的过程，而第二部分能通过对kmem中freelist字段的使用和proc数组的使用，对xv6内存管理和进程管理有初步了解。

### System call tracing

该部分是让我们实现破产版的trace，打印系统调用名称和调用的进程id。应该是很简单的。只需要通过静态数组记录syscallid和sycallname。然后在trap进内核，调用syscall后，通过id打印
出当前系统调用的名称和进程id。

### Sysinfo

该部分是打印出当前空闲内存数目和状态不是UNUSED的进程个数（看清楚了，是不是UNUSED的进程个数，我在这里也是没看清，可恶）。前者可以通过数freelist的个数，再乘以4096即可，而后
者也是可以直接通过遍历proc数组，判断其状态得出数据。有一点需要注意的就是由于内核使用的页表和用户态不一样，所以要参考stat中，使用copyout方法，遍历用户页表将该虚拟地址转化为
物理地址，再将sysinfo拷贝到该物理地址。因为内核是一一映射的。具体我就不解释，看xv6book对内存空间解释的图片，见下一节pgtbl。

一共花费时间：2小时

## pgtbl

## traps

## lazy

## cow

## thread

这个实验不是在内核中进行操作。主要是让我们用户态线程和熟悉线程安全。我觉得实验的一大亮点就是第一部分实现了用户态线程。我之前虽然是知道用户态线程和内核线程的概念，但是也只是
像高中那样背诵式的说出它们的区别，然后自己看过内核线程的实现源码，但是对用户态线程一直是很模糊，这回实现了，是真正的让我理解了内核线程和用户态线程的区别。

### switching between threads

实现用户态线程切换。首先是create的实现，我一开始的思考是保存所有的32个寄存器和func函数，但是我发现是没有必要的，只需要保存callee需要保存的14个即可，caller保存的编译器已经
为我们自动保存了，所以这里thread_switch怎么写也就不言而喻了。create时注意两个特殊寄存器的初始化，ra寄存器需要保存为func指针的值，当第一次调度时会从func的第一条指令开始执行
，而sp则需要保存为thread结构体中栈顶的值，注意是(uint64)t->stack + STACK_SIZE - 1，别忘了-1。因为栈是自上向下增长。调用thread_switch时参数顺序不要写错（我这里写错了，导致
pagefault，卡了一会）。

### Using threads 

就是最基本的用锁保护数据结构。唯一需要注意的是最好是一个bucket一个锁，这样可以大大提速。

### Barrier

实现一个类似于内存屏障的东西。对于barrier函数的流程，首先是用锁保护nthread，每个线程访问时首先需要获取锁，才能对nthread加一。然后判断是否是最后一个到来的线程，是则唤醒所有
线程，将round加1，nthread置0，这两个别忘了。否则就wait释放锁并且睡眠。注意wait被唤醒后还是会抢锁，这是条件变量wait的流程。所以在方法最后要释放锁，不然会死锁的。

一共花费时间：2小时

## lock

## fs

## mmap

## net

## alloc




